// RUN: llzk-opt -split-input-file %s 2>&1 | FileCheck --enable-var-scope %s

// This IR mimics an idiom that could be generated by the zirgen frontend
#map = affine_map<()[s0, s1] -> (s0 + s1)>
module attributes { veridise.lang = "llzk" } {
  llzk.struct @A<[@X, @Y, @N]> {
    func @compute(%0: !llzk.array<@N x !llzk.felt>) -> !llzk.struct<@A<[@X, @Y, @N]>> {
      %self = new_struct : <@A<[@X, @Y, @N]>>
      return %self : !llzk.struct<@A<[@X, @Y, @N]>>
    }
    func @constrain(%self: !llzk.struct<@A<[@X, @Y, @N]>>, %0: !llzk.array<@N x !llzk.felt>) {
      return
    }
  }
  llzk.struct @B<[@X, @Y, @N]> {
    field @a : !llzk.struct<@A<[@X, @Y, #map]>>
    func @compute(%a0: !llzk.array<@N x !llzk.felt>) -> !llzk.struct<@B<[@X, @Y, @N]>> {
      %self = new_struct : <@B<[@X, @Y, @N]>>
      %0 = read_const @X : index
      %1 = read_const @Y : index
      %2 = unifiable_cast %a0 : (!llzk.array<@N x !llzk.felt>) -> !llzk.array<#map x !llzk.felt>
      %3 = call @A::@compute(%2){()[%0, %1]} : (!llzk.array<#map x !llzk.felt>) -> !llzk.struct<@A<[@X, @Y, #map]>>
      writef %self[@a] = %3 : !llzk.struct<@B<[@X, @Y, @N]>>, !llzk.struct<@A<[@X, @Y, #map]>>
      return %self : !llzk.struct<@B<[@X, @Y, @N]>>
    }
    func @constrain(%self: !llzk.struct<@B<[@X, @Y, @N]>>, %a0: !llzk.array<@N x !llzk.felt>) {
      %2 = unifiable_cast %a0 : (!llzk.array<@N x !llzk.felt>) -> !llzk.array<#map x !llzk.felt>
      %a = readf %self[@a] : !llzk.struct<@B<[@X, @Y, @N]>>, !llzk.struct<@A<[@X, @Y, #map]>>
      call @A::@constrain(%a, %2) : (!llzk.struct<@A<[@X, @Y, #map]>>, !llzk.array<#map x !llzk.felt>) -> ()
      return
    }
  }
}
//       CHECK: #map = affine_map<()[s0, s1] -> (s0 + s1)>
//       CHECK: module attributes {veridise.lang = "llzk"} {
// CHECK-LABEL:   llzk.struct @A<[@X, @Y, @N]> {
// CHECK-LABEL:     func @compute
//  CHECK-SAME:                  (%[[A0:[0-9a-zA-Z_\.]+]]: !llzk.array<@N x !llzk.felt>) -> !llzk.struct<@A<[@X, @Y, @N]>> {
//  CHECK-NEXT:       %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@A<[@X, @Y, @N]>>
//  CHECK-NEXT:       return %[[SELF]] : !llzk.struct<@A<[@X, @Y, @N]>>
//  CHECK-NEXT:     }
// CHECK-LABEL:     func @constrain
//  CHECK-SAME:                   (%[[SELF:[0-9a-zA-Z_\.]+]]: !llzk.struct<@A<[@X, @Y, @N]>>, %[[A0:[0-9a-zA-Z_\.]+]]: !llzk.array<@N x !llzk.felt>) {
//  CHECK-NEXT:       return
//  CHECK-NEXT:     }
//  CHECK-NEXT:   }
// CHECK-LABEL:   llzk.struct @B<[@X, @Y, @N]> {
//  CHECK-NEXT:     field @a : !llzk.struct<@A<[@X, @Y, #map]>>
// CHECK-LABEL:     func @compute
//  CHECK-SAME:                  (%[[A0:[0-9a-zA-Z_\.]+]]: !llzk.array<@N x !llzk.felt>) -> !llzk.struct<@B<[@X, @Y, @N]>> {
//  CHECK-NEXT:       %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@B<[@X, @Y, @N]>>
//  CHECK-NEXT:       %[[T0:[0-9a-zA-Z_\.]+]] = read_const @X : index
//  CHECK-NEXT:       %[[T1:[0-9a-zA-Z_\.]+]] = read_const @Y : index
//  CHECK-NEXT:       %[[T2:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A0]] : (!llzk.array<@N x !llzk.felt>) -> !llzk.array<#map x !llzk.felt>
//  CHECK-NEXT:       %[[T3:[0-9a-zA-Z_\.]+]] = call @A::@compute(%[[T2]]) {()[%[[T0]], %[[T1]]]} : (!llzk.array<#map x !llzk.felt>) -> !llzk.struct<@A<[@X, @Y, #map]>>
//  CHECK-NEXT:       writef %[[SELF]][@a] = %[[T3]] : <@B<[@X, @Y, @N]>>, !llzk.struct<@A<[@X, @Y, #map]>>
//  CHECK-NEXT:       return %[[SELF]] : !llzk.struct<@B<[@X, @Y, @N]>>
//  CHECK-NEXT:     }
// CHECK-LABEL:     func @constrain
//  CHECK-SAME:                    (%[[SELF:[0-9a-zA-Z_\.]+]]: !llzk.struct<@B<[@X, @Y, @N]>>, %[[A0:[0-9a-zA-Z_\.]+]]: !llzk.array<@N x !llzk.felt>) {
//  CHECK-NEXT:       %[[T0:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A0]] : (!llzk.array<@N x !llzk.felt>) -> !llzk.array<#map x !llzk.felt>
//  CHECK-NEXT:       %[[T1:[0-9a-zA-Z_\.]+]] = readf %[[SELF]][@a] : <@B<[@X, @Y, @N]>>, !llzk.struct<@A<[@X, @Y, #map]>>
//  CHECK-NEXT:       call @A::@constrain(%[[T1]], %[[T0]]) : (!llzk.struct<@A<[@X, @Y, #map]>>, !llzk.array<#map x !llzk.felt>) -> ()
//  CHECK-NEXT:       return
//  CHECK-NEXT:     }
//  CHECK-NEXT:   }
//  CHECK-NEXT: }

// -----

#map1 = affine_map<()[s0, s1] -> (s0 + s1)>
#map2 = affine_map<()[s0, s1, s2] -> (s0 + s1 + s2)>
module attributes {veridise.lang = "llzk"} {
  llzk.struct @T1<[]> {
    func @compute() -> !llzk.struct<@T1<[]>> {
      %self = new_struct : <@T1<[]>>
      return %self : !llzk.struct<@T1<[]>>
    }
    func @constrain(%self : !llzk.struct<@T1<[]>>) {
      return
    }
  }
  llzk.struct @T2<[@N]> {
    func @compute() -> !llzk.struct<@T2<[@N]>> {
      %self = new_struct : <@T2<[@N]>>
      return %self : !llzk.struct<@T2<[@N]>>
    }
    func @constrain(%self : !llzk.struct<@T2<[@N]>>) {
      return
    }
  }
  llzk.struct @T3<[@A, @B, @C, @D, @E]> {
    func @compute() -> !llzk.struct<@T3<[@A, @B, @C, @D, @E]>> {
      %self = new_struct : <@T3<[@A, @B, @C, @D, @E]>>
      return %self : !llzk.struct<@T3<[@A, @B, @C, @D, @E]>>
    }
    func @constrain(%self : !llzk.struct<@T3<[@A, @B, @C, @D, @E]>>) {
      return
    }
  }
  llzk.struct @Tester<[@S0, @S1]> {
    func @compute(%0: index, %1: i1, %2: !llzk.felt, %3: !llzk.struct<@T1<[]>>,
                  %4: !llzk.struct<@T2<[1]>>, %5: !llzk.struct<@T2<[@S0]>>,
                  %6: !llzk.struct<@T2<[7]>>, %7: !llzk.struct<@T2<[!llzk.felt]>>,
                  %8: !llzk.array<2,2 x !llzk.felt>, %9: !llzk.array<2,@S0 x !llzk.felt>,
                  %10: !llzk.array<2,7 x !llzk.felt>, %11: !llzk.string, %12: !llzk.tvar<@S1>,
                  %18: !llzk.struct<@T3<[1, 7, @S0, 1, !llzk.struct<@T2<[1]>>]>>,
                  %20: !llzk.array<1, 7, @S0, 1 x !llzk.struct<@T2<[1]>>>) -> !llzk.struct<@Tester<[@S0, @S1]>> {
      %self = new_struct : <@Tester<[@S0, @S1]>>
      // Tests for equality
      %r0 = unifiable_cast %0 : (index) -> index
      %r1 = unifiable_cast %1 : (i1) -> i1
      %r2 = unifiable_cast %2 : (!llzk.felt) -> !llzk.felt
      %r3 = unifiable_cast %3 : (!llzk.struct<@T1<[]>>) -> !llzk.struct<@T1<[]>>
      %r4 = unifiable_cast %4 : (!llzk.struct<@T2<[1]>>) -> !llzk.struct<@T2<[1]>>
      %r5 = unifiable_cast %5 : (!llzk.struct<@T2<[@S0]>>) -> !llzk.struct<@T2<[@S0]>>
      %r6 = unifiable_cast %6 : (!llzk.struct<@T2<[7]>>) -> !llzk.struct<@T2<[#map1]>>
      %r7 = unifiable_cast %7 : (!llzk.struct<@T2<[!llzk.felt]>>) -> !llzk.struct<@T2<[!llzk.felt]>>
      %r8 = unifiable_cast %8 : (!llzk.array<2,2 x !llzk.felt>) -> !llzk.array<2,2 x !llzk.felt>
      %r9 = unifiable_cast %9 : (!llzk.array<2,@S0 x !llzk.felt>) -> !llzk.array<2,@S0 x !llzk.felt>
      %r10 = unifiable_cast %10 : (!llzk.array<2,7 x !llzk.felt>) -> !llzk.array<2,#map1 x !llzk.felt>
      %r11 = unifiable_cast %11 : (!llzk.string) -> !llzk.string
      // Test that a type variable unifies with any type
      %r12 = unifiable_cast %12 : (!llzk.tvar<@S1>) -> index
      %13 = unifiable_cast %2 : (!llzk.felt) -> !llzk.tvar<@S1>
      // Test that if structs have the same name they unify if their params unify
      %19 = unifiable_cast %18 : (!llzk.struct<@T3<[1, 7, @S0, 1, !llzk.struct<@T2<[1]>>]>>) -> !llzk.struct<@T3<[#map1, #map1, 1, @S0, !llzk.struct<@T2<[#map2]>>]>>
      %21 = unifiable_cast %20 : (!llzk.array<1, 7, @S0, 1 x !llzk.struct<@T2<[1]>>>) -> !llzk.array<#map1, #map1, 1, @S0 x !llzk.struct<@T2<[#map2]>>>
      return %self : !llzk.struct<@Tester<[@S0, @S1]>>
    }
    func @constrain(%self: !llzk.struct<@Tester<[@S0, @S1]>>, %0: index, %1: i1, %2: !llzk.felt, %3: !llzk.struct<@T1<[]>>,
                  %4: !llzk.struct<@T2<[1]>>, %5: !llzk.struct<@T2<[@S0]>>,
                  %6: !llzk.struct<@T2<[7]>>, %7: !llzk.struct<@T2<[!llzk.felt]>>,
                  %8: !llzk.array<2,2 x !llzk.felt>, %9: !llzk.array<2,@S0 x !llzk.felt>,
                  %10: !llzk.array<2,7 x !llzk.felt>, %11: !llzk.string, %12: !llzk.tvar<@S1>,
                  %18: !llzk.struct<@T3<[1, 7, @S0, 1, !llzk.struct<@T2<[1]>>]>>,
                  %20: !llzk.array<1, 7, @S0, 1 x !llzk.struct<@T2<[1]>>>) {
      return
    }
  }
}

//       CHECK: module attributes {veridise.lang = "llzk"} {
// CHECK-LABEL:  llzk.struct @Tester<[@S0, @S1]> {
// CHECK-LABEL:    func @compute(
//  CHECK-SAME:                  %[[A0:[0-9a-zA-Z_\.]+]]: index,
//  CHECK-SAME:                  %[[A1:[0-9a-zA-Z_\.]+]]: i1,
//  CHECK-SAME:                  %[[A2:[0-9a-zA-Z_\.]+]]: !llzk.felt,
//  CHECK-SAME:                  %[[A3:[0-9a-zA-Z_\.]+]]: !llzk.struct<@T1<[]>>,
//  CHECK-SAME:                  %[[A4:[0-9a-zA-Z_\.]+]]: !llzk.struct<@T2<[1]>>,
//  CHECK-SAME:                  %[[A5:[0-9a-zA-Z_\.]+]]: !llzk.struct<@T2<[@S0]>>,
//  CHECK-SAME:                  %[[A6:[0-9a-zA-Z_\.]+]]: !llzk.struct<@T2<[7]>>,
//  CHECK-SAME:                  %[[A7:[0-9a-zA-Z_\.]+]]: !llzk.struct<@T2<[!llzk.felt]>>,
//  CHECK-SAME:                  %[[A8:[0-9a-zA-Z_\.]+]]: !llzk.array<2,2 x !llzk.felt>,
//  CHECK-SAME:                  %[[A9:[0-9a-zA-Z_\.]+]]: !llzk.array<2,@S0 x !llzk.felt>,
//  CHECK-SAME:                  %[[A10:[0-9a-zA-Z_\.]+]]: !llzk.array<2,7 x !llzk.felt>,
//  CHECK-SAME:                  %[[A11:[0-9a-zA-Z_\.]+]]: !llzk.string,
//  CHECK-SAME:                  %[[A12:[0-9a-zA-Z_\.]+]]: !llzk.tvar<@S1>,
//  CHECK-SAME:                  %[[A13:[0-9a-zA-Z_\.]+]]: !llzk.struct<@T3<[1, 7, @S0, 1, !llzk.struct<@T2<[1]>>]>>,
//  CHECK-SAME:                  %[[A14:[0-9a-zA-Z_\.]+]]: !llzk.array<1,7,@S0,1 x !llzk.struct<@T2<[1]>>>
//  CHECK-SAME:    ) -> !llzk.struct<@Tester<[@S0, @S1]>> {
//  CHECK-NEXT:      %[[SELF:[0-9a-zA-Z_\.]+]] = new_struct : <@Tester<[@S0, @S1]>>
//  CHECK-NEXT:      %[[T0:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A0]] : (index) -> index
//  CHECK-NEXT:      %[[T1:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A1]] : (i1) -> i1
//  CHECK-NEXT:      %[[T2:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A2]] : (!llzk.felt) -> !llzk.felt
//  CHECK-NEXT:      %[[T3:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A3]] : (!llzk.struct<@T1<[]>>) -> !llzk.struct<@T1<[]>>
//  CHECK-NEXT:      %[[T4:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A4]] : (!llzk.struct<@T2<[1]>>) -> !llzk.struct<@T2<[1]>>
//  CHECK-NEXT:      %[[T5:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A5]] : (!llzk.struct<@T2<[@S0]>>) -> !llzk.struct<@T2<[@S0]>>
//  CHECK-NEXT:      %[[T6:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A6]] : (!llzk.struct<@T2<[7]>>) -> !llzk.struct<@T2<[#map]>>
//  CHECK-NEXT:      %[[T7:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A7]] : (!llzk.struct<@T2<[!llzk.felt]>>) -> !llzk.struct<@T2<[!llzk.felt]>>
//  CHECK-NEXT:      %[[T8:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A8]] : (!llzk.array<2,2 x !llzk.felt>) -> !llzk.array<2,2 x !llzk.felt>
//  CHECK-NEXT:      %[[T9:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A9]] : (!llzk.array<2,@S0 x !llzk.felt>) -> !llzk.array<2,@S0 x !llzk.felt>
//  CHECK-NEXT:      %[[T10:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A10]] : (!llzk.array<2,7 x !llzk.felt>) -> !llzk.array<2,#map x !llzk.felt>
//  CHECK-NEXT:      %[[T11:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A11]] : (!llzk.string) -> !llzk.string
//  CHECK-NEXT:      %[[T12:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A12]] : (!llzk.tvar<@S1>) -> index
//  CHECK-NEXT:      %[[T13:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A2]] : (!llzk.felt) -> !llzk.tvar<@S1>
//  CHECK-NEXT:      %[[T14:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A13]] : (!llzk.struct<@T3<[1, 7, @S0, 1, !llzk.struct<@T2<[1]>>]>>) -> !llzk.struct<@T3<[#map, #map, 1, @S0, !llzk.struct<@T2<[#map1]>>]>>
//  CHECK-NEXT:      %[[T15:[0-9a-zA-Z_\.]+]] = unifiable_cast %[[A14]] : (!llzk.array<1,7,@S0,1 x !llzk.struct<@T2<[1]>>>) -> !llzk.array<#map,#map,1,@S0 x !llzk.struct<@T2<[#map1]>>>
//  CHECK-NEXT:      return %[[SELF]] : !llzk.struct<@Tester<[@S0, @S1]>>
//  CHECK-NEXT:    }
// CHECK-LABEL:    func @constrain(
//  CHECK-SAME:                    %[[SELF:[0-9a-zA-Z_\.]+]]: !llzk.struct<@Tester<[@S0, @S1]>>,
//  CHECK-SAME:                    %[[A0:[0-9a-zA-Z_\.]+]]: index,
//  CHECK-SAME:                    %[[A1:[0-9a-zA-Z_\.]+]]: i1,
//  CHECK-SAME:                    %[[A2:[0-9a-zA-Z_\.]+]]: !llzk.felt,
//  CHECK-SAME:                    %[[A3:[0-9a-zA-Z_\.]+]]: !llzk.struct<@T1<[]>>,
//  CHECK-SAME:                    %[[A4:[0-9a-zA-Z_\.]+]]: !llzk.struct<@T2<[1]>>,
//  CHECK-SAME:                    %[[A5:[0-9a-zA-Z_\.]+]]: !llzk.struct<@T2<[@S0]>>,
//  CHECK-SAME:                    %[[A6:[0-9a-zA-Z_\.]+]]: !llzk.struct<@T2<[7]>>,
//  CHECK-SAME:                    %[[A7:[0-9a-zA-Z_\.]+]]: !llzk.struct<@T2<[!llzk.felt]>>,
//  CHECK-SAME:                    %[[A8:[0-9a-zA-Z_\.]+]]: !llzk.array<2,2 x !llzk.felt>,
//  CHECK-SAME:                    %[[A9:[0-9a-zA-Z_\.]+]]: !llzk.array<2,@S0 x !llzk.felt>,
//  CHECK-SAME:                    %[[A10:[0-9a-zA-Z_\.]+]]: !llzk.array<2,7 x !llzk.felt>,
//  CHECK-SAME:                    %[[A11:[0-9a-zA-Z_\.]+]]: !llzk.string,
//  CHECK-SAME:                    %[[A12:[0-9a-zA-Z_\.]+]]: !llzk.tvar<@S1>,
//  CHECK-SAME:                    %[[A13:[0-9a-zA-Z_\.]+]]: !llzk.struct<@T3<[1, 7, @S0, 1, !llzk.struct<@T2<[1]>>]>>,
//  CHECK-SAME:                    %[[A14:[0-9a-zA-Z_\.]+]]: !llzk.array<1,7,@S0,1 x !llzk.struct<@T2<[1]>>>
//  CHECK-SAME:    ) {
//  CHECK-NEXT:      return
//  CHECK-NEXT:    }
//  CHECK-NEXT:  }
//  CHECK-NEXT: }



